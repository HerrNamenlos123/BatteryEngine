
#include "Battery/pch.h"
#include "Battery/DefaultShaders.h"

namespace Battery {

	// A very basic vertex shader to be used for almost everything

	const std::string BATTERY_SHADER_SOURCE_VERTEX_SIMPLE = "\n"
		"\n"
		"#version 130\n"
		"\n"
		"attribute vec4 al_pos;\n"
		"attribute vec4 al_color;\n"
		"\n"
		"uniform mat4 al_projview_matrix;\n"
		"\n"
		"varying vec4 color;\n"
		"varying vec2 screenPos;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	screenPos = al_pos.xy;\n"
		"	color = al_color;\n"
		"	gl_Position = al_projview_matrix * al_pos;\n"
		"}\n"
		"\n";



	// For rendering antialiased lines

	const std::string BATTERY_SHADER_SOURCE_FRAGMENT_LINE =
		"\n"
		"#version 130\n"
		"\n"
		"out vec4 FragColor;\n"
		"\n"
		"uniform vec2 line_p1;\n"
		"uniform vec2 line_p2;\n"
		"uniform float line_thickness;\n"
		"uniform float line_falloff;\n"
		"\n"
		"varying vec4 color;\n"
		"varying vec2 screenPos;\n"
		"\n"
		"float lineDistance(vec2 P, vec2 L1, vec2 L2) {\n"
		"    float lower = distance(L1, L2);\n"
		"\n"
		"    if (lower != 0.0)\n"
		"        return abs((L2.x - L1.x) * (L1.y - P.y) - (L1.x - P.x) * (L2.y - L1.y)) / lower;\n"
		"    else\n"
		"        return 0.0;\n"
		"}\n"
		"\n"
		"float distanceAroundLine(vec2 P, vec2 L1, vec2 L2) {\n"
		"\n"
		"    vec2 aToB = L2 - L1;\n"
		"    vec2 aToP = P - L1;\n"
		"    vec2 bToP = P - L2;\n"
		"\n"
		"    if (length(aToB) == 0.0)\n"
		"        return length(aToP);\n"
		"\n"
		"    if (dot(aToB, aToP) < 0.0) {\n"
		"        return distance(P, L1);\n"
		"    }\n"
		"    else if (dot(-aToB, bToP) < 0.0) {\n"
		"        return distance(P, L2);\n"
		"    }\n"
		"\n"
		"    return lineDistance(P, L1, L2);\n"
		"}\n"
		"\n"
		"void main()\n"
		"{\n"
		"    float dist = distanceAroundLine(screenPos, line_p1, line_p2);\n"
		"\n"
		"    float a = line_thickness * 0.5 - line_falloff;\n"
		"    float b = line_thickness * 0.5;\n"
		"\n"
		"    if (a == b && dist > b)\n"
		"        discard;\n"
		"\n"
		"    FragColor = vec4(color.xyz, 1.0 / (a - b) * dist + b / (b - a));\n"
		"}\n"
		"\n";






	// For drawing antialiased circles

	const std::string BATTERY_SHADER_SOURCE_FRAGMENT_CIRCLE = "\n"
		"\n"
		"#version 130\n"
		"\n"
		"out vec4 FragColor;\n"
		"\n"
		"uniform vec2 circle_center;\n"
		"uniform float circle_radius;\n"
		"uniform float circle_falloff;\n"
		"\n"
		"varying vec4 color;\n"
		"varying vec2 uv;\n"
		"varying vec2 screenPos;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	float dist = distance(screenPos, circle_center);\n"
		"\n"
		"	float a = circle_radius - circle_falloff;\n"
		"	float b = circle_radius;\n"
		"\n"
		"	if (a == b && dist > b)\n"
		"		discard;\n"
		"\n"
		"	FragColor = vec4(color.xyz, 1.0 / (a - b) * dist + b / (b - a));\n"
		"}\n"
		"\n";



	// For drawing antialiased arcs

	const std::string BATTERY_SHADER_SOURCE_FRAGMENT_ARC = "\n"
		"\n"
		"	#version 130\n"
		"\n"
		"out vec4 FragColor;\n"
		"\n"
		"uniform vec2 arc_center;\n"
		"uniform float arc_radius;\n"
		"uniform float arc_start_angle;\n"
		"uniform float arc_end_angle;\n"
		"uniform float arc_thickness;\n"
		"uniform float arc_falloff;\n"
		"\n"
		"varying vec4 color;\n"
		"varying vec2 uv;\n"
		"varying vec2 screenPos;\n"
		"\n"
		"float PI = 3.1415926535897f;\n"
		"\n"
		"float arcCircleDistance(vec2 P) {\n"
		"	float distanceToCenter = distance(P, arc_center);\n"
		"\n"
		"	return abs(arc_radius - distanceToCenter);\n"
		"}\n"
		"\n"
		"float distanceAroundArc(vec2 P) {\n"
		"\n"
		"	vec2 centerToPos = P - arc_center;\n"
		"	float fragmentAngle = atan(centerToPos.y, -centerToPos.x) + PI;\n"
		"\n"
		"	if (arc_start_angle < arc_end_angle) {  // Normal case\n"
		"		if (fragmentAngle >= arc_start_angle && fragmentAngle <= arc_end_angle) {\n"
		"			return arcCircleDistance(P);\n"
		"		}\n"
		"	}\n"
		"	else {\n"
		"		if (fragmentAngle <= arc_end_angle || fragmentAngle >= arc_start_angle) {\n"
		"			return arcCircleDistance(P);\n"
		"		}\n"
		"	}\n"
		"\n"
		"	vec2 p1 = arc_center + vec2(cos(arc_start_angle), -sin(arc_start_angle)) * arc_radius;\n"
		"	vec2 p2 = arc_center + vec2(cos(arc_end_angle), -sin(arc_end_angle)) * arc_radius;\n"
		"\n"
		"	float distance1 = distance(P, p1);\n"
		"	float distance2 = distance(P, p2);\n"
		"\n"
		"	return min(distance1, distance2);\n"
		"}\n"
		"\n"
		"void main()\n"
		"{\n"
		"	float dist = distanceAroundArc(screenPos);\n"
		"\n"
		"	float a = arc_thickness / 2.0 - arc_falloff;\n"
		"	float b = arc_thickness / 2.0;\n"
		"\n"
		"	if (dist > b) {\n"
		"		discard;\n"
		"		return;\n"
		"	}\n"
		"\n"
		"	FragColor = vec4(color.xyz, 1.0 / (a - b) * dist + b / (b - a));\n"
		"}\n";






	// Shaders for drawing flat colored or gradient quads

	const std::string BATTERY_SHADER_SOURCE_FRAGMENT_COLOR_GRADIENT = "\n"
		"\n"
		"#version 130\n"
		"\n"
		"out vec4 FragColor;\n"
		"\n"
		"varying vec4 color;\n"
		"varying vec2 uv;\n"
		"varying vec2 screenPos;\n"
		"\n"
		"void main()\n"
		"{\n"
		"\n"
		"	FragColor = color;\n"
		"}\n"
		"\n";
}


